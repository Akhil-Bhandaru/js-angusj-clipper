"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ClipperError_1 = require("./ClipperError");
var ClipperOffset_1 = require("./ClipperOffset");
var addPathOrPaths = function (offset, inputDatas) {
    if (inputDatas === undefined) {
        return;
    }
    // add each input
    for (var i = 0, maxi = inputDatas.length; i < maxi; i++) {
        var inputData = inputDatas[i];
        // add the path/paths
        var pathOrPaths = inputData.data;
        if (!pathOrPaths || pathOrPaths.length <= 0) {
            continue;
        }
        // is it a path or paths?
        if (Array.isArray(pathOrPaths[0])) {
            // paths
            offset.addPaths(pathOrPaths, inputData.joinType, inputData.endType);
        }
        else {
            // path
            offset.addPath(pathOrPaths, inputData.joinType, inputData.endType);
        }
    }
};
function offsetToPathsOrPolyTree(polyTreeMode, nativeClipperLib, params) {
    var filledData = __assign({ arcTolerance: 0.25, miterLimit: 2 }, params);
    var offset = new ClipperOffset_1.ClipperOffset(nativeClipperLib, filledData.miterLimit, filledData.arcTolerance);
    //noinspection UnusedCatchParameterJS
    try {
        addPathOrPaths(offset, params.offsetInputs);
        if (!polyTreeMode) {
            return offset.executeToPaths(params.delta, params.cleanDistance);
        }
        else {
            if (params.cleanDistance !== undefined) {
                throw new ClipperError_1.ClipperError("cleaning is not available for poly tree results");
            }
            return offset.executeToPolyTree(params.delta);
        }
    }
    catch (err) {
        return undefined;
    }
    finally {
        offset.dispose();
    }
}
function offsetToPaths(nativeClipperLib, params) {
    return offsetToPathsOrPolyTree(false, nativeClipperLib, params);
}
exports.offsetToPaths = offsetToPaths;
function offsetToPolyTree(nativeClipperLib, params) {
    return offsetToPathsOrPolyTree(true, nativeClipperLib, params);
}
exports.offsetToPolyTree = offsetToPolyTree;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2Zmc2V0RnVuY3Rpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29mZnNldEZ1bmN0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQThDO0FBQzlDLGlEQUFnRDtBQTBGaEQsSUFBTSxjQUFjLEdBQUcsVUFBQyxNQUFxQixFQUFFLFVBQXFDO0lBQ2xGLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtRQUM1QixPQUFPO0tBQ1I7SUFFRCxpQkFBaUI7SUFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN2RCxJQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFaEMscUJBQXFCO1FBQ3JCLElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUMzQyxTQUFTO1NBQ1Y7UUFFRCx5QkFBeUI7UUFDekIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2pDLFFBQVE7WUFDUixNQUFNLENBQUMsUUFBUSxDQUFDLFdBQTRCLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEY7YUFBTTtZQUNMLE9BQU87WUFDUCxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQTJCLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDcEY7S0FDRjtBQUNILENBQUMsQ0FBQztBQUVGLFNBQVMsdUJBQXVCLENBQzlCLFlBQXFCLEVBQ3JCLGdCQUEwQyxFQUMxQyxNQUFvQjtJQUVwQixJQUFNLFVBQVUsY0FDZCxZQUFZLEVBQUUsSUFBSSxFQUNsQixVQUFVLEVBQUUsQ0FBQyxJQUNWLE1BQU0sQ0FDVixDQUFDO0lBRUYsSUFBTSxNQUFNLEdBQUcsSUFBSSw2QkFBYSxDQUM5QixnQkFBZ0IsRUFDaEIsVUFBVSxDQUFDLFVBQVUsRUFDckIsVUFBVSxDQUFDLFlBQVksQ0FDeEIsQ0FBQztJQUVGLHFDQUFxQztJQUNyQyxJQUFJO1FBQ0YsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixPQUFPLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbEU7YUFBTTtZQUNMLElBQUksTUFBTSxDQUFDLGFBQWEsS0FBSyxTQUFTLEVBQUU7Z0JBQ3RDLE1BQU0sSUFBSSwyQkFBWSxDQUFDLGlEQUFpRCxDQUFDLENBQUM7YUFDM0U7WUFDRCxPQUFPLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDL0M7S0FDRjtJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osT0FBTyxTQUFTLENBQUM7S0FDbEI7WUFBUztRQUNSLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxTQUFnQixhQUFhLENBQzNCLGdCQUEwQyxFQUMxQyxNQUFvQjtJQUVwQixPQUFPLHVCQUF1QixDQUFDLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLENBQXNCLENBQUM7QUFDdkYsQ0FBQztBQUxELHNDQUtDO0FBRUQsU0FBZ0IsZ0JBQWdCLENBQzlCLGdCQUEwQyxFQUMxQyxNQUFvQjtJQUVwQixPQUFPLHVCQUF1QixDQUFDLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLENBQXlCLENBQUM7QUFDekYsQ0FBQztBQUxELDRDQUtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpcHBlckVycm9yIH0gZnJvbSBcIi4vQ2xpcHBlckVycm9yXCI7XG5pbXBvcnQgeyBDbGlwcGVyT2Zmc2V0IH0gZnJvbSBcIi4vQ2xpcHBlck9mZnNldFwiO1xuaW1wb3J0IHsgRW5kVHlwZSwgSm9pblR5cGUgfSBmcm9tIFwiLi9lbnVtc1wiO1xuaW1wb3J0IHsgTmF0aXZlQ2xpcHBlckxpYkluc3RhbmNlIH0gZnJvbSBcIi4vbmF0aXZlL05hdGl2ZUNsaXBwZXJMaWJJbnN0YW5jZVwiO1xuaW1wb3J0IHsgUGF0aCwgUmVhZG9ubHlQYXRoIH0gZnJvbSBcIi4vUGF0aFwiO1xuaW1wb3J0IHsgUGF0aHMsIFJlYWRvbmx5UGF0aHMgfSBmcm9tIFwiLi9QYXRoc1wiO1xuaW1wb3J0IHsgUG9seVRyZWUgfSBmcm9tIFwiLi9Qb2x5VHJlZVwiO1xuXG4vKipcbiAqIEEgc2luZ2xlIGlucHV0IChvZiBtdWx0aXBsZSBwb3NzaWJsZSBpbnB1dHMpIGZvciB0aGUgb2Zmc2V0VG9QYXRocyAvIG9mZnNldFRvUG9seVRyZWUgb3BlcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9mZnNldElucHV0IHtcbiAgLyoqXG4gICAqIEpvaW4gdHlwZS5cbiAgICovXG4gIGpvaW5UeXBlOiBKb2luVHlwZTtcblxuICAvKipcbiAgICogRW5kIHR5cGUuXG4gICAqL1xuICBlbmRUeXBlOiBFbmRUeXBlO1xuXG4gIC8qKlxuICAgKiBEYXRhIG9mIG9uZSBvZiB0aGUgUGF0aCBvciBQYXRocyB0byBiZSB1c2VkIGluIHByZXBhcmF0aW9uIGZvciBvZmZzZXR0aW5nLlxuICAgKlxuICAgKiBBbGwgJ291dGVyJyBQYXRocyBtdXN0IGhhdmUgdGhlIHNhbWUgb3JpZW50YXRpb24sIGFuZCBhbnkgJ2hvbGUnIHBhdGhzIG11c3QgaGF2ZSByZXZlcnNlIG9yaWVudGF0aW9uLiBDbG9zZWQgcGF0aHMgbXVzdCBoYXZlIGF0IGxlYXN0IDMgdmVydGljZXMuXG4gICAqIE9wZW4gcGF0aHMgbWF5IGhhdmUgYXMgZmV3IGFzIG9uZSB2ZXJ0ZXguIE9wZW4gcGF0aHMgY2FuIG9ubHkgYmUgb2Zmc2V0IHdpdGggcG9zaXRpdmUgZGVsdGFzLlxuICAgKi9cbiAgZGF0YTogUmVhZG9ubHlQYXRoIHwgUmVhZG9ubHlQYXRocztcbn1cblxuLyoqXG4gKiBQYXJhbXMgZm9yIHRoZSBwb2x5Z29uIG9mZnNldCBvcGVyYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT2Zmc2V0UGFyYW1zIHtcbiAgLyoqXG4gICAqIEZpcnN0bHksIHRoaXMgZmllbGQvcHJvcGVydHkgaXMgb25seSByZWxldmFudCB3aGVuIEpvaW5UeXBlID0gUm91bmQgYW5kL29yIEVuZFR5cGUgPSBSb3VuZC5cbiAgICpcbiAgICogU2luY2UgZmxhdHRlbmVkIHBhdGhzIGNhbiBuZXZlciBwZXJmZWN0bHkgcmVwcmVzZW50IGFyY3MsIHRoaXMgZmllbGQvcHJvcGVydHkgc3BlY2lmaWVzIGEgbWF4aW11bSBhY2NlcHRhYmxlIGltcHJlY2lzaW9uICgndG9sZXJhbmNlJykgd2hlbiBhcmNzIGFyZVxuICAgKiBhcHByb3hpbWF0ZWQgaW4gYW4gb2Zmc2V0dGluZyBvcGVyYXRpb24uIFNtYWxsZXIgdmFsdWVzIHdpbGwgaW5jcmVhc2UgJ3Ntb290aG5lc3MnIHVwIHRvIGEgcG9pbnQgdGhvdWdoIGF0IGEgY29zdCBvZiBwZXJmb3JtYW5jZSBhbmQgaW4gY3JlYXRpbmcgbW9yZVxuICAgKiB2ZXJ0aWNlcyB0byBjb25zdHJ1Y3QgdGhlIGFyYy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgQXJjVG9sZXJhbmNlIGlzIDAuMjUgdW5pdHMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgbWF4aW11bSBkaXN0YW5jZSB0aGUgZmxhdHRlbmVkIHBhdGggd2lsbCBkZXZpYXRlIGZyb20gdGhlICd0cnVlJyBhcmMgd2lsbCBiZSBubyBtb3JlXG4gICAqIHRoYW4gMC4yNSB1bml0cyAoYmVmb3JlIHJvdW5kaW5nKS5cbiAgICpcbiAgICogUmVkdWNpbmcgdG9sZXJhbmNlcyBiZWxvdyAwLjI1IHdpbGwgbm90IGltcHJvdmUgc21vb3RobmVzcyBzaW5jZSB2ZXJ0ZXggY29vcmRpbmF0ZXMgd2lsbCBzdGlsbCBiZSByb3VuZGVkIHRvIGludGVnZXIgdmFsdWVzLiBUaGUgb25seSB3YXkgdG8gYWNoaWV2ZVxuICAgKiBzdWItaW50ZWdlciBwcmVjaXNpb24gaXMgdGhyb3VnaCBjb29yZGluYXRlIHNjYWxpbmcgYmVmb3JlIGFuZCBhZnRlciBvZmZzZXR0aW5nIChzZWUgZXhhbXBsZSBiZWxvdykuXG4gICAqXG4gICAqIEl0J3MgaW1wb3J0YW50IHRvIG1ha2UgQXJjVG9sZXJhbmNlIGEgc2Vuc2libGUgZnJhY3Rpb24gb2YgdGhlIG9mZnNldCBkZWx0YSAoYXJjIHJhZGl1cykuIExhcmdlIHRvbGVyYW5jZXMgcmVsYXRpdmUgdG8gdGhlIG9mZnNldCBkZWx0YSB3aWxsIHByb2R1Y2VcbiAgICogcG9vciBhcmMgYXBwcm94aW1hdGlvbnMgYnV0LCBqdXN0IGFzIGltcG9ydGFudGx5LCB2ZXJ5IHNtYWxsIHRvbGVyYW5jZXMgd2lsbCBzdWJzdGFudGlhbGx5IHNsb3cgb2Zmc2V0dGluZyBwZXJmb3JtYW5jZSB3aGlsZSBwcm92aWRpbmcgdW5uZWNlc3NhcnlcbiAgICogZGVncmVlcyBvZiBwcmVjaXNpb24uIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gYmUgYW4gaXNzdWUgd2hlbiBvZmZzZXR0aW5nIHBvbHlnb25zIHdob3NlIGNvb3JkaW5hdGVzIGhhdmUgYmVlbiBzY2FsZWQgdG8gcHJlc2VydmUgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuICAgKlxuICAgKiBFeGFtcGxlOiBJbWFnaW5lIGEgc2V0IG9mIHBvbHlnb25zIChkZWZpbmVkIGluIGZsb2F0aW5nIHBvaW50IGNvb3JkaW5hdGVzKSB0aGF0IGlzIHRvIGJlIG9mZnNldCBieSAxMCB1bml0cyB1c2luZyByb3VuZCBqb2lucywgYW5kIHRoZSBzb2x1dGlvbiBpcyB0b1xuICAgKiByZXRhaW4gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIHVwIHRvIGF0IGxlYXN0IDYgZGVjaW1hbCBwbGFjZXMuXG4gICAqIFRvIHByZXNlcnZlIHRoaXMgZGVncmVlIG9mIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiwgYW5kIGdpdmVuIHRoYXQgQ2xpcHBlciBhbmQgQ2xpcHBlck9mZnNldCBib3RoIG9wZXJhdGUgb24gaW50ZWdlciBjb29yZGluYXRlcywgdGhlIHBvbHlnb25cbiAgICogY29vcmRpbmF0ZXMgd2lsbCBiZSBzY2FsZWQgdXAgYnkgMTA4IChhbmQgcm91bmRlZCB0byBpbnRlZ2VycykgcHJpb3IgdG8gb2Zmc2V0dGluZy4gQm90aCBvZmZzZXQgZGVsdGEgYW5kIEFyY1RvbGVyYW5jZSB3aWxsIGFsc28gbmVlZCB0byBiZSBzY2FsZWRcbiAgICogYnkgdGhpcyBzYW1lIGZhY3Rvci4gSWYgQXJjVG9sZXJhbmNlIHdhcyBsZWZ0IHVuc2NhbGVkIGF0IHRoZSBkZWZhdWx0IDAuMjUgdW5pdHMsIGV2ZXJ5IGFyYyBpbiB0aGUgc29sdXRpb24gd291bGQgY29udGFpbiBhIGZyYWN0aW9uIG9mIDQ0IFRIT1VTQU5EXG4gICAqIHZlcnRpY2VzIHdoaWxlIHRoZSBmaW5hbCBhcmMgaW1wcmVjaXNpb24gd291bGQgYmUgMC4yNSDDlyAxMC04IHVuaXRzIChpZSBvbmNlIHNjYWxpbmcgd2FzIHJldmVyc2VkKS4gSG93ZXZlciwgaWYgMC4xIHVuaXRzIHdhcyBhbiBhY2NlcHRhYmxlIGltcHJlY2lzaW9uXG4gICAqIGluIHRoZSBmaW5hbCB1bnNjYWxlZCBzb2x1dGlvbiwgdGhlbiBBcmNUb2xlcmFuY2Ugc2hvdWxkIGJlIHNldCB0byAwLjEgw5cgc2NhbGluZ19mYWN0b3IgKDAuMSDDlyAxMDggKS4gTm93IGlmIHNjYWxpbmcgaXMgYXBwbGllZCBlcXVhbGx5IHRvIGJvdGhcbiAgICogQXJjVG9sZXJhbmNlIGFuZCB0byBEZWx0YSBPZmZzZXQsIHRoZW4gaW4gdGhpcyBleGFtcGxlIHRoZSBudW1iZXIgb2YgdmVydGljZXMgKHN0ZXBzKSBkZWZpbmluZyBlYWNoIGFyYyB3b3VsZCBiZSBhIGZyYWN0aW9uIG9mIDIzLlxuICAgKlxuICAgKiBUaGUgZm9ybXVsYSBmb3IgdGhlIG51bWJlciBvZiBzdGVwcyBpbiBhIGZ1bGwgY2lyY3VsYXIgYXJjIGlzIC4uLiBQaSAvIGFjb3MoMSAtIGFyY190b2xlcmFuY2UgLyBhYnMoZGVsdGEpKVxuICAgKi9cbiAgYXJjVG9sZXJhbmNlPzogbnVtYmVyOyAvLyBkZWZhdWx0cyB0byAwLjI1XG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcGVydHkgc2V0cyB0aGUgbWF4aW11bSBkaXN0YW5jZSBpbiBtdWx0aXBsZXMgb2YgZGVsdGEgdGhhdCB2ZXJ0aWNlcyBjYW4gYmUgb2Zmc2V0IGZyb20gdGhlaXIgb3JpZ2luYWwgcG9zaXRpb25zIGJlZm9yZSBzcXVhcmluZyBpcyBhcHBsaWVkLlxuICAgKiAoU3F1YXJpbmcgdHJ1bmNhdGVzIGEgbWl0ZXIgYnkgJ2N1dHRpbmcgaXQgb2ZmJyBhdCAxIMOXIGRlbHRhIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbmFsIHZlcnRleC4pXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBNaXRlckxpbWl0IGlzIDIgKGllIHR3aWNlIGRlbHRhKS4gVGhpcyBpcyBhbHNvIHRoZSBzbWFsbGVzdCBNaXRlckxpbWl0IHRoYXQncyBhbGxvd2VkLiBJZiBtaXRlcmluZyB3YXMgdW5yZXN0cmljdGVkIChpZSB3aXRob3V0XG4gICAqIGFueSBzcXVhcmluZyksIHRoZW4gb2Zmc2V0cyBhdCB2ZXJ5IGFjdXRlIGFuZ2xlcyB3b3VsZCBnZW5lcmF0ZSB1bmFjY2VwdGFibHkgbG9uZyAnc3Bpa2VzJy5cbiAgICovXG4gIG1pdGVyTGltaXQ/OiBudW1iZXI7IC8vIGRlZmF1bHRzIHRvIDIgKHR3aWNlIGRlbHRhKVxuXG4gIC8qKlxuICAgKiBOZWdhdGl2ZSBkZWx0YSB2YWx1ZXMgc2hyaW5rIHBvbHlnb25zIGFuZCBwb3NpdGl2ZSBkZWx0YSBleHBhbmQgdGhlbS5cbiAgICovXG4gIGRlbHRhOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9uZSBvciBtb3JlIGlucHV0cyB0byB1c2UgZm9yIHRoZSBvZmZzZXQgb3BlcmF0aW9uLlxuICAgKi9cbiAgb2Zmc2V0SW5wdXRzOiBPZmZzZXRJbnB1dFtdO1xuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIG5vdCB1bmRlZmluZWQgdGhlbiBjbGVhbmluZyBvZiB0aGUgcmVzdWx0IHBvbHlnb24gd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqIFRoaXMgb3BlcmF0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIG91dHB1dCBmb3JtYXQgaXMgbm90IGEgcG9seSB0cmVlLlxuICAgKi9cbiAgY2xlYW5EaXN0YW5jZT86IG51bWJlcjtcbn1cblxuY29uc3QgYWRkUGF0aE9yUGF0aHMgPSAob2Zmc2V0OiBDbGlwcGVyT2Zmc2V0LCBpbnB1dERhdGFzOiBPZmZzZXRJbnB1dFtdIHwgdW5kZWZpbmVkKSA9PiB7XG4gIGlmIChpbnB1dERhdGFzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhZGQgZWFjaCBpbnB1dFxuICBmb3IgKGxldCBpID0gMCwgbWF4aSA9IGlucHV0RGF0YXMubGVuZ3RoOyBpIDwgbWF4aTsgaSsrKSB7XG4gICAgY29uc3QgaW5wdXREYXRhID0gaW5wdXREYXRhc1tpXTtcblxuICAgIC8vIGFkZCB0aGUgcGF0aC9wYXRoc1xuICAgIGNvbnN0IHBhdGhPclBhdGhzID0gaW5wdXREYXRhLmRhdGE7XG4gICAgaWYgKCFwYXRoT3JQYXRocyB8fCBwYXRoT3JQYXRocy5sZW5ndGggPD0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaXMgaXQgYSBwYXRoIG9yIHBhdGhzP1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhPclBhdGhzWzBdKSkge1xuICAgICAgLy8gcGF0aHNcbiAgICAgIG9mZnNldC5hZGRQYXRocyhwYXRoT3JQYXRocyBhcyBSZWFkb25seVBhdGhzLCBpbnB1dERhdGEuam9pblR5cGUsIGlucHV0RGF0YS5lbmRUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGF0aFxuICAgICAgb2Zmc2V0LmFkZFBhdGgocGF0aE9yUGF0aHMgYXMgUmVhZG9ubHlQYXRoLCBpbnB1dERhdGEuam9pblR5cGUsIGlucHV0RGF0YS5lbmRUeXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9mZnNldFRvUGF0aHNPclBvbHlUcmVlKFxuICBwb2x5VHJlZU1vZGU6IGJvb2xlYW4sXG4gIG5hdGl2ZUNsaXBwZXJMaWI6IE5hdGl2ZUNsaXBwZXJMaWJJbnN0YW5jZSxcbiAgcGFyYW1zOiBPZmZzZXRQYXJhbXNcbik6IFBhdGhzIHwgUG9seVRyZWUgfCB1bmRlZmluZWQge1xuICBjb25zdCBmaWxsZWREYXRhID0ge1xuICAgIGFyY1RvbGVyYW5jZTogMC4yNSxcbiAgICBtaXRlckxpbWl0OiAyLFxuICAgIC4uLnBhcmFtc1xuICB9O1xuXG4gIGNvbnN0IG9mZnNldCA9IG5ldyBDbGlwcGVyT2Zmc2V0KFxuICAgIG5hdGl2ZUNsaXBwZXJMaWIsXG4gICAgZmlsbGVkRGF0YS5taXRlckxpbWl0LFxuICAgIGZpbGxlZERhdGEuYXJjVG9sZXJhbmNlXG4gICk7XG5cbiAgLy9ub2luc3BlY3Rpb24gVW51c2VkQ2F0Y2hQYXJhbWV0ZXJKU1xuICB0cnkge1xuICAgIGFkZFBhdGhPclBhdGhzKG9mZnNldCwgcGFyYW1zLm9mZnNldElucHV0cyk7XG4gICAgaWYgKCFwb2x5VHJlZU1vZGUpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuZXhlY3V0ZVRvUGF0aHMocGFyYW1zLmRlbHRhLCBwYXJhbXMuY2xlYW5EaXN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJhbXMuY2xlYW5EaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGlwcGVyRXJyb3IoXCJjbGVhbmluZyBpcyBub3QgYXZhaWxhYmxlIGZvciBwb2x5IHRyZWUgcmVzdWx0c1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQuZXhlY3V0ZVRvUG9seVRyZWUocGFyYW1zLmRlbHRhKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZmluYWxseSB7XG4gICAgb2Zmc2V0LmRpc3Bvc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0VG9QYXRocyhcbiAgbmF0aXZlQ2xpcHBlckxpYjogTmF0aXZlQ2xpcHBlckxpYkluc3RhbmNlLFxuICBwYXJhbXM6IE9mZnNldFBhcmFtc1xuKTogUGF0aHMgfCB1bmRlZmluZWQge1xuICByZXR1cm4gb2Zmc2V0VG9QYXRoc09yUG9seVRyZWUoZmFsc2UsIG5hdGl2ZUNsaXBwZXJMaWIsIHBhcmFtcykgYXMgUGF0aHMgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRUb1BvbHlUcmVlKFxuICBuYXRpdmVDbGlwcGVyTGliOiBOYXRpdmVDbGlwcGVyTGliSW5zdGFuY2UsXG4gIHBhcmFtczogT2Zmc2V0UGFyYW1zXG4pOiBQb2x5VHJlZSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBvZmZzZXRUb1BhdGhzT3JQb2x5VHJlZSh0cnVlLCBuYXRpdmVDbGlwcGVyTGliLCBwYXJhbXMpIGFzIFBvbHlUcmVlIHwgdW5kZWZpbmVkO1xufVxuIl19